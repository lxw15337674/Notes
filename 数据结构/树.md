# 树
## 详解
https://juejin.im/post/5e9960346fb9a03c9580051f

## 概念
由 n（n>=1）个有限节点组成一个具有层次关系的集合；把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的，基本呈一对多关系，树也可以看做是图的特殊形式。

类似公司的组织架构图
![image](https://user-gold-cdn.xitu.io/2017/6/26/c85baf15cf24b6af6d45d86f5f98fe92?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 基本名词
- 树的层级：从根节点开始到达一个节点的路径所包含的边的数量。
- 树的高度：树中所有节点的最大层级。
- 平衡因子：左子树的高度-右子树的高度。

## 树的遍历
- 先序遍历：父->左子->右子
- 中序遍历：左子->父->右子
- 后序遍历：左子->右子->父
![image](https://user-gold-cdn.xitu.io/2020/4/20/17195319685c3cbf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 完全二叉树
完全二叉树通俗点说就是，只有最后一层和倒数第二层有叶节点，而且最后一层的叶节点一定在左部连续，而倒数第二层的叶节点一定在右部连续。
![image](https://user-gold-cdn.xitu.io/2020/4/21/1719a8dab11770c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

## 二叉查找树
二叉查找树（Binary Search Tree）就是我们常说的BST，它也是在二叉树的基础上进行了限制，每个节点的左子节点需要小于它，而右子节点需要大于它。也是很好理解哈。它的插入操作是比较好实现了，比较困难的是它的删除操作。删除一个节点后，也要保证BST保持相应的性质，它分为三种情况
- 这个节点没有子节点
- 这个节点有1个子节点
- 这个节点有2个子节点
第一种情况是比较容易的，直接删除掉就行了；第二种情况也还行，就将唯一的这个子节点上移代替它就行了；最困难的是第三种情况，当它有两个节点的时候没有办法简单的上移哪个节点，于是我们就找一个节点来替代它，就找右子树的最小的节点，也就是右子树的最左边的左节点。
![image](https://user-gold-cdn.xitu.io/2020/4/22/171a0d49e1c0b8dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## AVL树
AVL树是一种自平衡二叉搜索树，AVL树本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树），在AVL树中任何节点的两个子树的高度最大差别为一，也就是说这种树会在添加或移除节点时尽量试着成为一棵完全树，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是 O（log n），增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。


## 红黑树

- 每个节点不是红色的就是黑色的。
- 树的根节点永远是黑色
- 所有叶节点都是黑色的，它们都是NULL来表示
- 红色的节点的两个子节点都是黑色的，红色的节点不能相邻，也就说红色节点的父节点和子节点都必须为黑色
- 从当前节点到它的叶节点（也就是NULL）的所有路径中都包含相同数量的黑色节点
