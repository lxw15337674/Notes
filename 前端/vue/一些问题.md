# 一些问题
## Vue是如何检测数组变化？
- 使用函数劫持的方法，重写了数组的方法。
- vue将data中的数组，进行了原型链重写，只想了自己定义的数组原型方法，每次调用api时，都会通知依赖更新。

## 为何Vue采用异步渲染？
如果不采用异步更新，每次更新数据都会对当前组件进行重新渲染，为了性能考虑，vue会在本次数据更新结束后，再去异步更新视图。

## nextTick实现原理
利用宏任务和微任务，让方法异步执行。

## computed和watch的差异
computed和watch都是watcher
1. computed是是基于它们的响应式依赖进行缓存的，只有当依赖的属性发生变化时才会重新求值。
适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。
2. method每次都要重新执行，每次触发重新渲染时，方法都会再次执行。
3. watch用来监听数据的变化，执行对应的方法。

## watch中的deep:true是如何实现的
当指定deep为true时，如果当前监控的值是数组类型，就会对对象中的每一项进行求值，此时会将当前watcher存入对应属性的依赖中，这样数组中对象发生变化也会通知数据更新。

## 在哪个生命周期内调用异步请求
可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。

在 created 钩子函数中调用异步请求优点：

- 能更快获取到服务端数据，减少页面loading 时间；
- ssr不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；
> created时，无法操作DOM节点，无法找到相关的元素

## 何时需要使用`beforeDestory`
- 使用$on方法
- 清除定时器
- 解除事件绑定

## Vue 模板编译原理
将模板转为ast（抽象语法树），作为虚拟DOM。

## v-if和v-show
- 当条件不成立时，v-if不会渲染DOM元素。
- v-show操作的是样式(display)，切换当前DOM的显示和隐藏。

## v-for与v-if为什么不能连用
v-for优先级高，连用会把v-if给各个元素都添加一下，造成性能问题。

## vnode来描述一个DOM结构
vnode 是作为数据和视图的一种映射关系

```
<div id='container'><p></p></div>

let obj = {
    tag:'div',
    data:{
        id:'container'
    }
    children:[
        {tag:'p',
        data:{},
        chidlren:[]
        }

    ]
}

```