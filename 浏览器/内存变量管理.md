# 内存变量管理
## 内存的存放
js内存空间存在栈(stack)、堆(heap)。池（一般会归类在栈中）。

其中栈存放变量、堆存放复杂对象、池存放常量

### 基本类型
基本数据类型存在栈中。因为基本数据类型占用空间小，大小固定，通过按值访问。
> 不包含闭包中的变量，会被保存到堆内存中。
### 引用数据类型
引用数据类型存在堆中，因为这种值的大小不固定，占据空间大，如果存在栈中，会影响性能。所以引用数据类型在栈中只存储对象的地址引用（地址指针）。  
当查询引用类型的变量时， 先从栈中读取内存地址，然后再到堆中根据地址找到值。

![image](https://user-gold-cdn.xitu.io/2019/9/22/16d579280bb577ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 内存回收
js有自动垃圾收集机制，垃圾回收每隔一段时间就会执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。
- 局部变量和全局变量的销毁
    - 局部变量：局部作用域中，当函数执行完毕，局部变量就会被回收。
    - 全局变量：局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。
- 以google的v8引擎为例，v8引擎中所有的js对象都是通过堆来进行内存分配。
    - 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。
    - 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。
- v8引擎将堆内存中的js对象进行分代管理
    - 新生代：存活周期较短的JS对象，如临时变量、字符串等。
    - 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。
### 垃圾回收器工作流程
1. 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
2. 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
3. 做内存整理。
### 垃圾回收算法
核心思想是如何判断内存中的变量不再使用。常用垃圾回收算法分为两种。
#### 引用计数（现代浏览器不再使用）
引用计数算法就是看一个对象是否有指向他的引用，如果没有其他对象指向它，说明该对象已经不再需要了。
```
// 创建一个对象person，他有两个指向属性age和name的引用
var person = {
    age: 12,
    name: 'aaaa'
};

person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收

var p = person; 
person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收

p = null;           //原person对象已经没有引用，很快会被回收
```
引用计数有一个致命问题，就是循环引用，如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。

#### 标记清除（常用）
标记清除算法就是看一个对象是否能从根部到达。从根部不能到达的对象就会被标记为不再使用。
无法触及的对象包含了没有引用的对象概念，但反之未必成立。

```
    email.message = document.createElement(“div”);
    displayList.appendChild(email.message);

    // 稍后从displayList中清除DOM元素
    displayList.removeAllChildren();
```
上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。
### 垃圾回收机制
V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。
- 新生代算法
新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。
在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。

- 老生代算法
老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。
 >   对象出现在老生代空间中的条件 ：
    - 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
    - To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。
>
在老生代中，启动标记清除算法的情况：
- 某一个空间没有分块的时候
- 空间中被对象超过一定限制
- 空间不能保证新生代中的对象移动到老生代中
在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。
### 详解
[002：V8 引擎如何进行垃圾内存的回收？](http://47.98.159.95/my_blog/js-v8/002.html#v8-%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6)
[V8 下的垃圾回收机制](http://caibaojian.com/interview-map/frontend/#v8-%E4%B8%8B%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6)
## 内存泄漏
对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。
### 常见情况
1. 意外的全局变量
2. 被遗忘的计数器或回调函数
3. 闭包
4. 脱离DOM的引用
```
var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
};
function doStuff() {
    image.src = 'http://some.url/image';
    button.click();
    console.log(text.innerHTML);
    // 更多逻辑
}
function removeButton() {
    // 按钮是 body 的后代元素
    document.body.removeChild(document.getElementById('button'));
    // 此时，仍旧存在一个全局的 #button 的引用
    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。
}
```
如果代码中保存了表格某一个 <td> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 <td> 以外的其它节点。实际情况并非如此：此 <td> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 <td> 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。




