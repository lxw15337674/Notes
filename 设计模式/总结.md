# 设计模式总结
## 设计原则
1. **S – Single Responsibility Principle 单一职责原则**

2. - 一个程序只做好一件事
   - 如果功能过于复杂就拆分开，每个部分保持独立

3. **O – OpenClosed Principle 开放/封闭原则**

4. - 对扩展开放，对修改封闭
   - 增加需求时，扩展新代码，而非修改已有代码

5. **L – Liskov Substitution Principle 里氏替换原则**

6. - 子类能覆盖父类
   - 父类能出现的地方子类就能出现

7. **I – Interface Segregation Principle 接口隔离原则**

8. - 保持接口的单一独立
   - 类似单一职责原则，这里更关注接口

9. **D – Dependency Inversion Principle 依赖倒转原则**

10. - 面向接口编程，依赖于抽象而不依赖于具
    - 使用方只关注接口而不关注具体类的实现
## 设计模式

| 设计模式          | 描述                                                         | 例子                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单例模式          | 一个类只能构造出唯一实例                                     | vuex                                                         |
| 工厂模式          | 对创建对象逻辑的封装                                         | new 创建实例                                                 |
| 观察者模式        | 当一个对象被修改时，自动通知所有依赖它的对象                 | Object.defineProperty()                                      |
| 发布者-订阅者模式 | 结合观察者和中介者模式，当发布者发布时，会有调度中心执行订阅者的订阅事件 | vue 的双向绑定                                               |
| 装饰器模式        | 对类的包装，动态扩展类的功能                                 | js 的装饰器， koa2 的洋葱模型（中间件）                      |
| 适配器模式        | 兼容新旧接口，对类的包装                                     | 多态                                                         |
| 代理模式          | 控制对象的访问                                               | proxy                                                        |
| 外观模式          | 隐藏系统内部逻辑，对外提供可以访问系统的接口                 | 封装                                                         |
| 策略模式          | 根据不同的场景，执行对应的操作                               | 重载                                                         |
| 代理模式          | 为一个对象提供一个代用品或占位符，以便控制对它的访问         | Proxy、HTML元 素事件代理                                     |
| 迭代模式          | 提供一种方法遍历一个聚合对象中各个元素                       | 链表                                                         |
| 中介者模式        | 处理同级对象之间的双向交互                                   | 聊天室， 聊天室里面的人之间并不能直接对话，而是通过聊天室这一媒介进行转发。 |
| 访问者模式        | 能够在不改变一个对象结构的前提下能够给对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中。 | 1.对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 |


## 详解
[前端需要了解的9种设计模式](https://segmentfault.com/a/1190000022396503)
[菜鸟教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)